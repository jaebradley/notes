# [Implementing Stripe-Like Idempotency Keys in Postgres](https://brandur.org/idempotency-keyss)

## What is an idempotency key

* Idempotency key is a unique value generated by a client and sent to API along with request
  * Server stores key to use for bookkeeping so if request fails partway through and client retries with same idempotency key value the server uses it to look up the request's state and continue from where it left off
  * Once the server knows that a request has definitively finished by either succeeding or failing in a way that's not recoverable it stores the request's results and associates them with the idempotency key - if a client makes a request with the same key, the server can short-circuit and return the stored results
  * Keys are not meant to be a permanent request archive but as a mechanism for near-term correctness
  * Servers should recycle keys out of the system after 24 hours or so

## Request Lifecycle   

* Request lifecycle for creating a new ride
  * Insert idempotency key record
  * Create a ride record to track ride that's about to happen
  * Create audit record for referencing ride
  * Make API call to Stripe to charge user for ride (note that this is calling third-party server)
  * Update ride record with created charge ID
  * Send user receipt via email
  * Update idempotency key with results
* Potential failure points
  * Inserting idempotency key or ride record fails due to constraint violation or database connectivity issue
  * API request to Stripe times out or errors in some other way
  * Mailgun (or other email sender) fails leaving user with credit card charge but no formal notification of transaction
  * Client disconnects while sending the request, which cancels operation

## Foreign State Mutations and Atomic Phases

* Identify the foreign state mutations - i.e. calling and manipulating data in another system (calling Stripe, sending email)
  * Calls within own infrastructure count - like emitting records to Kafka as part of atomic operations
* Atomic phase is a set of local state mutations that occur in transactions between foreign state mutations
  * Atomic phases should be safely committed before initiating any foreign state mutation
  * If foreign state mutation fails, local state will have record of what happened and can use the stored state to retry operation
* Recovery point is name of check point that we get to after any successfully executed atomic phase OR foreign state mutation
  * Allows a request that's been retried to jump back to the point in the lifecycle just before the last attempt failed
  * All requests will initially get a recovery point of `started` and at the end, `finished`
  * When in an atomic phase, the transition to a new recovery point should be committed as part of that phase's transaction
* In-band foreign state mutations make a request slower and more difficult to reason about and should be avoided when possible
  * Often times (like in the case of sending an email) it's possible to defer work to after the request completes by sending the work to a background job queue
  * Use a transactionally-staged job drain to hide jobs from workers until we've confirmed that they're ready to be worked on by isolating them in a transaction (basically, create a staged jobs table that is inserted to as part of a transaction, and then simultaneously have a worker read from this table periodically inside a transaction so it only reads jobs that have been committed)

## Designing Atomic Phases

* Upserting idempotency key is its own atomic phase
* Every foreign state mutation gets its own atomic phase
* All other operations between them are their own atomic phases - even if there are 100 operations against an ACID database between two foreign state mutations they can all safely belong to the same phase
* `tx1` - Create Idempotency Key (`started`)
* `tx2` - Create Ride & Create Ride Audit Record (`ride_created`)
* `tx3` - Charge User Via Stripe (Foreign State Mutation) & Update Ride Record (`charge_created`)
* `tx4` - Stage Email Receipt Job and Update Idempotency Key (`finished`)

## Atomic Phase Implementation

* Each atomic phase is wrapped in a transaction block and each phase returns one of three options
  * A `RecoveryPoint` which denotes progress
  * A `Response` which sets the recovery point as `finished` and returns a response to the user
    * Can be success response but also can return early with a non-recoverable error (invalid credit card number - no matter how many times request is retried, it will never go through)
  * A `NoOp` which indicates program flow continues but neither a recovery point nor response should be set

## Idempotency Key Upsert

* When a new idempotency key is seen, insert new row
* If key has been seen before, lock it - if already locked (i.e. `locked_at` is non-`null`) then return a `409 Conflict`
* If key is set to `finished`, then don't process and return response
* Use a `SERIALIZABLE` transaction to handle concurrency around two locks on the same key - if two different transactions try and lock any one key, one of them will be aborted

```ruby
atomic_phase(key) do
  key = IdempotencyKey.first(user_id: user.id, idempotency_key: key_val)

  if key
    # Programs sending multiple requests with different parameters but the
    # same idempotency key is a bug.
    if key.request_params != params
      halt 409, JSON.generate(wrap_error(Messages.error_params_mismatch))
    end

    # Only acquire a lock if the key is unlocked or its lock has expired
    # because the original request was long enough ago.
    if key.locked_at && key.locked_at > Time.now - IDEMPOTENCY_KEY_LOCK_TIMEOUT
      halt 409, JSON.generate(wrap_error(Messages.error_request_in_progress))
    end

    # Lock the key and update latest run unless the request is already
    # finished.
    if key.recovery_point != RECOVERY_POINT_FINISHED
      key.update(last_run_at: Time.now, locked_at: Time.now)
    end
  else
    key = IdempotencyKey.create(
      idempotency_key: key_val,
      locked_at:       Time.now,
      recovery_point:  RECOVERY_POINT_STARTED,
      request_method:  request.request_method,
      request_params:  Sequel.pg_jsonb(params),
      request_path:    request.path_info,
      user_id:         user.id,
    )
  end

  # no response and no need to set a recovery point
  NoOp.new
end
```

## Processing As A Directed Acyclic State Machine

* Each atomic phase will be activated from a recovery point, which was either from a recovered idempotency key, or set by a previous atmoic phase

```ruby
loop do
  case key.recovery_point
  when RECOVERY_POINT_STARTED
    atomic_phase(key) do
      ...
    end

  when RECOVERY_POINT_RIDE_CREATED
    atomic_phase(key) do
      ...
    end

  when RECOVERY_POINT_CHARGE_CREATED
    atomic_phase(key) do
      ....
    end

  when RECOVERY_POINT_FINISHED
    break

  else
    raise "Bug! Unhandled recovery point '#{key.recovery_point}'."
  end

  # If we got here, allow the loop to move us onto the next phase of the
  # request. Finished requests will break the loop.
end
```

* An idempotency key that was already finished will enter loop, break immediately, and send back whatever the stored response was

```ruby
# Example of Calling Stripe

atomic_phase(key) do
  # retrieve a ride record if necessary (i.e. we're recovering)
  ride = Ride.first(idempotency_key_id: key.id) if ride.nil?

  # if ride is still nil by this point, we have a bug
  raise "Bug! Should have ride for key at #{RECOVERY_POINT_RIDE_CREATED}." \
    if ride.nil?

  raise "Simulated fail with `raise_error` param." if raise_error

  # Rocket Rides is still a new service, so during our prototype phase
  # we're going to give $20 fixed-cost rides to everyone, regardless of
  # distance. We'll implement a better algorithm later to better
  # represent the cost in time and jetfuel on the part of our pilots.
  begin
    charge = Stripe::Charge.create({
      amount:      20_00,
      currency:    "usd",
      customer:    user.stripe_customer_id,
      description: "Charge for ride #{ride.id}",
    }, {
      # Pass through our own unique ID rather than the value
      # transmitted to us so that we can guarantee uniqueness to Stripe
      # across all Rocket Rides accounts.
      idempotency_key: "rocket-rides-atomic-#{key.id}"
    })
  rescue Stripe::CardError
    # Sets the response on the key and short circuits execution by
    # sending execution right to 'finished'.
    Response.new(402, wrap_error(Messages.error_payment(error: $!.message)))
  rescue Stripe::StripeError
    Response.new(503, wrap_error(Messages.error_payment_generic))
  else
    ride.update(stripe_charge_id: charge.id)
    RecoveryPoint.new(RECOVERY_POINT_CHARGE_CREATED)
  end
end
```