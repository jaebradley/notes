# 6.3 Finding exploitable parallelism

## Example:; sequential page renderer

* Component is the page-rendering portion of a browser application, which takes a page of HTML, and renders it into an image buffer
  * For simplicity, assuming HTML is only marked up text with image elements
* Simplest approach is to process the HTML document sequentially where any encountered text markup is rendered into an image buffer, and as image references are encountered to fetch the image over the network and draw it into the image buffer
  * Users will have to wait until all the text is rendered vs. rendering the text elements first, while leaving rectangular placeholders for the images, and then redrawing the images
* Downloading an image mostly involves waiting for I/O to complete, and during this time, the CPU does little work

## Result-bearing tasks: `Callable` and `Future`

* `Executor`s only take `Runnable`s as tasks
* `Runnable`s have a limited abstraction - `run` cannot return a value or throw a checked exception, although it can have side effects, like writing to a log file, or placing a result in a shared data structure
* Many tasks are effectively deferred computations like fetching a resource over the network, or computing a complicated function
  * For these types of tasks, `Callable` is a better abstraction as it expects `call` to return a value and anticipates that it might throw an exception
* In the `Executor` frameowkr, tasks that have been submitted, but not yet started, can always be cancelled
  * Tasks that have started can sometimes be cancelled, if they are responsive to interruption
  * Cancelling a task that has already completed has no effect
* `Future` represents the lifecycle of a task, and provides methods to test whether the task has completed or been cancelled, retrieve its result, and cancel the task
* The task lifecycle can only move forwards, so once a task is completed, it stays in that state forever
* If a `Future` has completed, the `Future` will return immediately or throw an exception
  * If a `Future` has not completed, it blocks until the task completes
  * If a `Future` completes and throws an exception, the exception gets wrapped in an `ExecutionException`
  * If the `Future` was cancelled, a `CancellationException` is thrown
* Can instantiate a `FutureTask` directly for a given `Runnable` or `Callable`

## Example: page renderer with `Future`

* Two tasks - ones that render the text and ones that download the images
* Create a `Callable` to download all the images, and submit them to an `ExecutorService`
  * Submission to the `ExecutorService` returns a `Future`
  * When the main thread gets to the point where it needs the images, it waits for the result by calling `Future#get`

```java
Callable>List<ImageData>> task = new Callable<>() {
  public List<ImageData> call() {
    List<ImageData> result = new ArrayList<>();
    for (ImageInfo imageInfo : imageInfos)
      result.add(imageInfo.downloadImage());
    return result;
  }
}
Future<List<ImageData>> future = executor.submit(task);

try {
  List<ImageData> imageData = future.get();
  for (ImageData data : imageData)
    renderImage(data);
} catch (InterruptedException e) {
  // Re-assert the thread's interrupted status
  Thread.currentThread().interrupt();
  // Don't need the result, so cancel the task
  future.cancel(true);
} catch (ExecutionException e) {
  throw launderThrowable(e.getCause());
}
```

## `CompletionService`: `Executor` meets `BlockingQueue`

* If there's a batch of computations to submit to an `Executor`, and you want to retrieve their results as they become available, could retain the `Future` associated with each task and repeatedly poll for completion by calling `get` with a timeout of `0`
* Submit `Callable` tasks to the `CompletionService` for execution
  * Use `take ` and `poll` to retrieve computation results, which are encapsulated in `Future`s
* The `ExecutorCompletionService` creates a `BlockingQueue` that holds the completed results
  * The `FutureTask` class has a `done` method that is called when the computation completes
  * The `QueueingFuture` class, which is a subclass of `FutureTask`, overrides `done` and places the result on the `BlockingQueue`
  * `take` and `poll` delegate to the `BlockingQueue`, blocking if results are not yet available

## Example: page renderer with `CompletionService`

* Create a separate task for downloading each image and execute them in a thread pool
* By fetching the result from a `CompletionService`, and rendering each image as soon as it is available, there's a more responsive user experience
* Multiple `ExecutorCompletionService`s can share a single `Executor` so it is fine to create an `ExecutorCompletionService` that is private to a particular computation while sharing a common `Executor`
  * A `CompletionService` acts as a handle for a batch of computations in the same way that a `Future` acts as a handle for a single computation
  * By remembering how many tasks were submitted to the `CompletionService` and counting how many completed results are retrieved, you can know when all the results for a given batch have been retrieved, even if you use a shared `Executor`

## Placing time limits on tasks

* Can use timed version of `Future.get` to execute tasks within a time budget - `Future.get` will return as soon as a result is ready, or throw `TimeoutException` if the result is not ready within the timeout period
* Need to stop timed tasks from running when they surpass their time budget
  * Task can manage their time budget and abort if it runs out of time or can cancel the task if the timeout expires
  * Timed `Future.get` completes with a `TimeoutException` if it exceeds its time budget, and the task can be cancelled through the `Future
* Example submits an ad-fetching task to an executor, computes the rest of the page content, and then waits for the ad until its time budget runs out
  * If the `get` times out, the method cancels the ad-fetching task and uses a default advertisment instead

```java
Future<Ad> f = exec.submit(new FetchAdTask());
Page page = renderPageBody();
Ad ad;
try {
  ad = f.get(someTimeBudget, NANOSECONDS);
} catch (ExecutionException e) {
  ad = DEFAULT_AD;
} catch (TimeoutException e) {
  ad = DEFAULT_AD;
  f.cancel(true);
}

page.setAd(ad);
return page;
```

## Example: a travel reservations portal

* The reservations portal calls third parties for information
  * If the page does not hear back from third parties in time, it will render what information has been provided in the allotted time or display placeholders
* Fetching information from one company is independent of fetching information from another one, so fetching information from a single company is a sensible task boundary
* For all of the `Future`s, use the `invokeAll` method, which takes a collection of tasks and returns a collection of `Future`s
  * The returned `Future`s are in the same order imposed by the input collection's iterator
  * The timed version will return when all the tasks have completed, the calling thread is interrupted, or the timeout expires
  * Any taks that are not complete when the timeout expires are cancelled
  * On return from `invokeAll`, each task will have either completed normally or been cancelled
